module QuasiFSplitness

using Oscar

exponent_vectors(poly) = leading_exponent_vector.(terms(poly))

"""
Evaluates the element of the Frobenius dual corresponding
to 'indices' for a polynomial ring (this happens to also be a splitting)
on the polynomial poly.

An element of the Frobenius dual is an element of 
Hom(F_*R, R), i.e. a map F_*R \\to R. 
Here, R = k[x_1, ..., x_n] is a polynomial ring, where
k is a field of characteristic p.

Such maps are in 1-1 correspondence with n-tuples
of integers mod p, where we have the maps
\\phi_{indices[1], ..., indices[n]},
as defined in the literature (see e.g. Ma-Polstra's notes).

Now, these maps are defined by projecting to the direct sum component,
which means we forget all but the terms which have exponent < indices[i] mod p
for the variable x_i, then we subtract the exponent of x_i by indices[i] and divide them all by p.

An example will be illustrive. Consider the element of the three-variable polynomial
ring k[x,y,z]: 

f = x^2y^3z + x^3y^2z^2 + x^8y^7z^7

and say that p = 5, then 

\\phi_{2,3,1}(f) = 1, and
\\phi_{3,2,2}(f) = 1 + xyz

Note: idk exactly what this is doing when you pass an element of a non-polynomial ring
... it probably throws an error on account of the use of 'gens'

Assumptions:

length(indices) == number of variables in the ring

indices \\in [0, ..., p-1]

"""
function polynomial_frobenius_splitting(p,poly,indices)
  coefs = coefficients(poly)
  exp_vecs = exponent_vectors(poly)
  vars = gens(parent(poly))

  length(exp_vecs[1]) != length(indices) && begin println("mismatched number of variables"); return end

  result = zero(poly)
  for i in 1:length(coefs)
    if all((exp_vecs[i] .% p) .== indices)
      new_exp_vec = div.(exp_vecs[i] .- indices,p) # the difision should be exact by the if statement
      new_term = prod(vars .^ new_exp_vec)
      result = result + new_term
    end
  end

  result

end#function

"""
By a standard argument, e.g. see Ma-Polstra,
Hom(F_*R, R) is generated by a single element,
which may be denoted 
\\phi_{p-1, ..., p-1} 
in the previous notation.
In Kawakami-Takamatsu-Yoshikawa, they denote this by u.

This function evaluates this generator at poly.
"""
function polynomial_frobenius_generator(p,poly) 
  nVars = length(gens(parent(poly)))

  polynomial_frobenius_splitting(p,poly,fill(p-1, nVars))
end#function
                                           


"""
Calculates if the hypersuface defined by the 
polynomial poly is F-split

note that p must be prime for this to have mathematical meaning
"""
function isFSplit(p,poly)
  #maybe TODO: check that p is prime


  fpower = poly^(p-1)

  for exponent_vector in exponent_vectors(fpower)
    if all(exponent_vector .< p)
      # We are F-split!!
      return true
    end
  end

  false
end#function

function quasiFSplitHeight(p,poly)

end#function

end#module
