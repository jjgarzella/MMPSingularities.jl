module QuasiFSplitness

using Oscar
using Memoize
using Combinatorics

exponent_vectors(poly) = leading_exponent_vector.(terms(poly))

"""
Evaluates the element of the Frobenius dual corresponding
to 'indices' for a polynomial ring (this happens to also be a splitting)
on the polynomial poly.

An element of the Frobenius dual is an element of 
Hom(F_*R, R), i.e. a map F_*R \\to R. 
Here, R = k[x_1, ..., x_n] is a polynomial ring, where
k is a field of characteristic p.

Such maps are in 1-1 correspondence with n-tuples
of integers mod p, where we have the maps
\\phi_{indices[1], ..., indices[n]},
as defined in the literature (see e.g. Ma-Polstra's notes).

Now, these maps are defined by projecting to the direct sum component,
which means we forget all but the terms which have exponent < indices[i] mod p
for the variable x_i, then we subtract the exponent of x_i by indices[i] and divide them all by p.

An example will be illustrive. Consider the element of the three-variable polynomial
ring k[x,y,z]: 

f = x^2y^3z + x^3y^2z^2 + x^8y^7z^7

and say that p = 5, then 

\\phi_{2,3,1}(f) = 1, and
\\phi_{3,2,2}(f) = 1 + xyz

Note: idk exactly what this is doing when you pass an element of a non-polynomial ring
... it probably throws an error on account of the use of 'gens'

Assumptions:

length(indices) == number of variables in the ring

indices \\in [0, ..., p-1]

"""
function polynomial_frobenius_splitting(p,poly,indices)
  coefs = coefficients(poly)
  exp_vecs = exponent_vectors(poly)
  vars = gens(parent(poly))

  length(exp_vecs[1]) != length(indices) && begin println("mismatched number of variables"); return end

  result = zero(poly)
  for i in 1:length(coefs)
    if all((exp_vecs[i] .% p) .== indices)
      new_exp_vec = div.(exp_vecs[i] .- indices,p) # the difision should be exact by the if statement
      new_term = prod(vars .^ new_exp_vec)
      result = result + new_term
    end
  end

  result

end#function

"""
By a standard argument, e.g. see Ma-Polstra,
Hom(F_*R, R) is generated by a single element,
which may be denoted 
\\phi_{p-1, ..., p-1} 
in the previous notation.
In Kawakami-Takamatsu-Yoshikawa, they denote this by u.

This function evaluates this generator at poly.
"""
function polynomial_frobenius_generator(p,poly) 
  nVars = length(gens(parent(poly)))

  polynomial_frobenius_splitting(p,poly,fill(p-1, nVars))
end#function

"""
This is not as space-efficient as it could be

Gives the ways of putting the numbers 1...sum(partition)
into length(unique(partition)) boxes where each box
is labeled by a part value and box labeled
by partition[i] has 
count(==(partition[i]),partition) elements

list is assumed to be a list of indices, i.e.
a list of integers with no repeated elements.

partition is assumed to be a list of positive
integers whose which is in increasing or decreasing
order 
(though I think one can get away with each value
being in a contiguous interval of indices, i.e.
[1;1;1;2;2;3] is ok but [1;1;2;1] is not)

The resulting output is an array which has the same
length as partition, whose i'th element is in the
bucket labeled by partition[i]
"""
@memoize function multicombinations(list,partition)
  #TODO: can this be more space-efficient as an iterator??
  # TODO: rewrite this function to allocate memory smarter

  if length(partition) == 0
    return [zeros(eltype(partition),0)]
  end
  
  first = partition[1]
  nFirst = count(==(first),partition)

  result = Vector{Vector{eltype(list)}}()
  for combo in Combinatorics.combinations(list,nFirst)
    withoutfirst = partition[partition .!= first]
    withoutcombo = list[list .∉ (combo,)] # ∉ is \notin 

    for multicombo in multicombinations(withoutcombo,withoutfirst)
      push!(result,[combo; multicombo])
    end
  end

  result
end#function

"""
finds the multicombinations of the set {1, ... n},
where n is the sum of the elements in partition
"""
function multicombinations(partition)
  multicombinations(collect(1:sum(partition)),partition)
end#function

function Δ₁(p,poly)
  
  # I don't know how computationally intense these operations are
  #    do them outside any loops just in case.
  terms_iter = terms(poly)
  allterms = collect(terms_iter)
  nTerms = length(allterms)

  res = zero(poly)
  for termlist in Combinatorics.combinations(allterms,p)
    
    for partition in Combinatorics.partitions(p)

      # the algorithm will still work without this line 
      # because div(1,p) == 0 so coef == 0 below...
      #
      # ...but let's not do the extra work.
      length(partition) == 1 && continue

      distParts = unique(partition)
      nDistParts = length(distParts)
      
      coef = div(multinomial(partition...),p)

      for multicombo in multicombinations(partition)
        newterm = one(poly)
        for i in 1:length(partition)
          exponent = partition[i]
          termind = multicombo[i]
          newterm = newterm * (termlist[termind])^exponent
        end
        res = res + coef * newterm
      end

    end

  end

  res
end#function

"""
Returns true if the polynomial poly
is in the "frobenius power" \\frak{m}^[p],
where {m} is the ideal of variables of the ring.

"""
function inPowerOfVariableIdeal(p,poly)
  # don't need this because exponent_vectors will have 
  # no elements for the zero polynomial
  #poly == zero(poly) && return true


  for exponent_vector in exponent_vectors(poly)
    if all(exponent_vector .< p)
      # We not in the power of the maximal ideal, we don't have any
      # powers that are big enough
      return false
    end
  end

  true
end#function

"""
Calculates if the hypersuface defined by the 
polynomial poly is F-split

note that p must be prime for this to have mathematical meaning
"""
function isFSplit(p,poly)
  #maybe TODO: check that p is prime

  !inPowerOfVariableIdeal(p,poly^(p-1))

end#function

function quasiFSplitHeight(p,poly)
  # TODO: understand how to check quasi-F-splitness for heights higher than 2,
  # and figure out how the "other elements" come into play
  

  # TODO: figure out why the computations don't seem to be working for the examples in 2204.10076 on page 59

end#function

end#module
