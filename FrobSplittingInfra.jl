module FrobSplittingInfra

using Oscar
using Memoize
using Combinatorics


include("griffiths-dwork-construction/Utils.jl")

export polynomial_frobenius_splitting
export polynomial_frobenius_generator
export multiply_then_split
export is_kernel_poly_frob_generator
export multicomibnations
export Δ₁, Δ₁l, Fstar_basis
export dim_of_homog_polys
export vector, matrix_of_lin_op
export lift_to_Int64
export index_of_term_not_in_frobenius_power_CY
export inPowerOfVariableIdeal
export isHomog, isFSplit
export matrix_of_multiply_then_split
export matrix_of_multiply_then_split_sortmodp



exponent_vectors(poly) = leading_exponent_vector.(terms(poly))

"""
Evaluates the element of the Frobenius dual corresponding
to 'indices' for a polynomial ring (this happens to also be a splitting)
on the polynomial poly.

An element of the Frobenius dual is an element of 
Hom(F_*R, R), i.e. a map F_*R \\to R. 
Here, R = k[x_1, ..., x_n] is a polynomial ring, where
k is a field of characteristic p.

Such maps are in 1-1 correspondence with n-tuples
of integers mod p, where we have the maps
\\phi_{indices[1], ..., indices[n]},
as defined in the literature (see e.g. Ma-Polstra's notes).

Now, these maps are defined by projecting to the direct sum component,
which means we forget all but the terms which have exponent < indices[i] mod p
for the variable x_i, then we subtract the exponent of x_i by indices[i] and divide them all by p.

An example will be illustrive. Consider the element of the three-variable polynomial
ring k[x,y,z]: 

f = x^2y^3z + x^3y^2z^2 + x^8y^7z^7

and say that p = 5, then 

\\phi_{2,3,1}(f) = 1, and
\\phi_{3,2,2}(f) = 1 + xyz

Note: idk exactly what this is doing when you pass an element of a non-polynomial ring
... it probably throws an error on account of the use of 'gens'

Assumptions:

length(indices) == number of variables in the ring

indices \\in [0, ..., p-1]

"""
function polynomial_frobenius_splitting(p,poly,indices)

  #coefs = collect(coefficients(poly)) # someday use iterator to make this more efficient?
  #exp_vecs = exponent_vectors(poly)
  vars = gens(parent(poly))

  poly == zero(poly) && return 0
  length(vars) != length(indices) && begin println("mismatched number of variables"); return end

  result = zero(poly)
  for i in 1:length(poly)
    t = term(poly, i)
    exp_vec = exponent_vector(t,1)

    if all((exp_vec .% p) .== indices)


      new_exp_vec = divexact.(exp_vec .- indices,p) # the difision should be exact by the if statement
      
      c = coeff(t,1)
      new_term = c * prod(vars .^ new_exp_vec) 
      # uses that gens and leading_exponent_vector are using the same variable order

      result = result + new_term
    end
  end

  result

end#function

"""
By a standard argument, e.g. see Ma-Polstra,
Hom(F_*R, R) is generated by a single element,
which may be denoted 
\\phi_{p-1, ..., p-1} 
in the previous notation.
In Kawakami-Takamatsu-Yoshikawa, they denote this by u.

This function evaluates this generator at poly.
"""
function polynomial_frobenius_generator(p,poly) 
  nVars = length(gens(parent(poly)))

  polynomial_frobenius_splitting(p,poly,fill(p-1, nVars))
end#function

"""
Multiplies the two polynomials f and g together
and then applies `polynomial_frobenius_splitting`
to the result.

This algorithm only stores the relevant terms,
forgetting all intermediate ones. 
It *should* use less memory than the usual one.

"""
function multiply_then_split(p,f,g,indices)

  result = zero(f)

  vars = gens(parent(f))


  for i in 1:length(f)
    t = term(f,i)
    for j in 1:length(g)
      u = term(g,j)

      prodterm = t*u

      exps = exponent_vector(prodterm,1)

      if all((exps .% p) .== indices)

        coef = coeff(prodterm,1)

        new_exp_vec = divexact.(exps .- indices,p) # the difision should be exact by the if statement

        newterm = coef * prod(vars .^ new_exp_vec) 

        result = result + newterm
      end

    end

  end

  result
end#function

function multiply_then_split(p,f,g)
    nVars = length(gens(parent(f)))

    multiply_then_split(p,f,g,fill(p-1, nVars))
end#function


"""
given two exponent vectors degs1 and degs2, 
will the term corresponding to them survive
the frobenius root? 

In other words, to these vectors sum to 
fill(p-1,n)?

degs1 and degs2 are assumed to be reduced mod p already

This function is meant to be used in tight inner loops,
so if there's any way to make it faster that would be good.

"""
function terms_are_relevant(p,degs1,degs2)
  n = length(degs1)
  
  relevant = true
  for k in 1:n
    #prod_exp_vec_mod_p[k] = degs[tInd,k] + mons[i][k] % p
    if degs1[k] + degs2[k] != p-1
      relevant = false
    end
  end

  relevant
end

#TODO: debug this
"""
Finds the matrix of multiplying by the polynomial with 
coefficients coefs and degrees degs
"""
function matrix_of_multiply_then_split_sortmodp(p,coefs,degs,d)
  n = size(degs,2)
  mons = Utils.gen_exp_vec(n,d)
  mons = reduce(vcat,transpose.(mons))

  nMons = size(mons,1)
  nTerms = size(degs,1)
    
  # Preprocessing
  reverseMons = Dict(mons[i,:] => i for i in 1:size(mons,1))
  reverseDegs = Dict(degs[i,:] => i for i in 1:size(degs,1))

  degs_modp = degs .% p
  mons_modp = mons .% p

  #TODO: remplace this with a view to imptove performance later
  #https://stackoverflow.com/questions/68344823/sortperm-for-matrix-sorting-in-julia-lang
  degs_perm = sortperm(view.(Ref(degs_modp),1:nTerms,:))
  mons_perm = sortperm(view.(Ref(mons_modp),1:nMons,:))
  #degs_perm = sortperm(collect(eachrow(degs_modp)))
  #mons_perm = sortperm(collect(eachrow(mons_modp)))

  #println("mons: $mons")
  #println("mons sorted: $(mons[mons_perm,:])")
  #println("mons sorted mod p: $(mons_modp[mons_perm,:])")
  #println("delta_1 sorted mod p: $(degs_modp[degs_perm,:])")

  # we need to traverse both arrays at once
  # we consider degs to be on the "left"
  left = true

  l = 1 # left index
  r = nMons # right index

  result = zeros(Int,nMons,nMons)

  while l ≤ nTerms && 1 ≤ r
    mon_modp = mons_modp[mons_perm[r],:]
    term_modp = degs_modp[degs_perm[l],:]
    if terms_are_relevant(p,mon_modp,term_modp)
      # we have a match!
     

      # Short preprocessing step: how many terms in degs have this exponent vector?
      nMatches = 1
      while l + nMatches ≤ nTerms && all(degs_modp[degs_perm[l+nMatches],:] .== term_modp)
        nMatches = nMatches + 1
      end

      # loop through all monomials and process each one
      while 1 ≤ r && all(mons_modp[mons_perm[r],:] .== mon_modp)

        mon = mons[mons_perm[r],:]
        for ll = l:(l + nMatches - 1)
            term = degs[degs_perm[ll],:]
            #print("found match ($ll,$r), ")
            #print("accessing term at ($(degs_perm[ll]),$(degs_perm[r])), ")
            #print("term $term multiplies with monomial $mon, ")
            
            # multiply then split the terms
            newterm = div.(mon .+ term .- fill(p-1,n), p)
            newcoefind = reverseDegs[term] 
            newcoef = coefs[newcoefind]
            row = reverseMons[newterm]
            col = reverseMons[mon]
            #println("setting matrix element ($row,$col)")
            result[row,col] += newcoef
        end

        r = r - 1
        left = true
        #0 < r && println("$r, true monomial: $(mons_perm[r])")
      end

      l = l + nMatches - 1
    else
      if left
        l = l + 1
        left = false
      else
        r = r - 1
        #0 < r && println("$r, true monomial: $(mons_perm[r])")
        left = true
      end
    end
  end

  result
end

"""
Computes the matrix of the 
linear operator of multiplying
by the polynomnial f with coefficients
coefs and degrees degs and then applying 
polynomial_frobenius_generator
on the vector space of homogeneous polynomials
of degree d

coefs - vector of coefficients
degs - 2d array of exponent vectors
"""
function matrix_of_multiply_then_split(p,coefs,degs,d)
  n = size(degs,2)
  mons = Utils.gen_exp_vec(n,d)
  mons = reduce(vcat,transpose.(mons))
  nMons = size(mons,1)

  reverseDict = Dict(mons[i] => i for i in 1:length(mons))

  result = zeros(nMons,nMons)
  
  #p_minus_ones = fill(n,p-1)
  #prod_exp_vec_mod_p = zeros(n)

  for i in 1:nMons
    # compute column i
    for tInd in 1:size(degs,1)

      relevant = true
      for k in 1:n
        #prod_exp_vec_mod_p[k] = degs[tInd,k] + mons[i][k] % p
        if degs[tInd,k] + mons[i,k] % p != p-1
          relevant = false
        end
      end

      if relevant
      #if all((degs[tInd,:] .+ mons[i]) .% p .== fill(n,p-1))
        # this is a relevant term
        exv_in_prod = degs[tInd,:] .+ mons[i,:]
        new_exv = divexact.(exv_in_prod .- fill(n,p-1),p)
        row = reverseDict[new_exv]
        result[row,i] += coefs[tInd]

      end
    end
  end

  result
end


"""
Returns true if the polynomial inputted is in the
kernel of the map u that gnerates the dual module
of F_*
"""
function in_kernel_poly_frob_generator(p,poly)
  nVars = length(gens(parent(poly)))
  indices = fill(p-1,nVars)

  for i in 1:length(poly)

    t = term(poly, i)
    exp_vec = exponent_vector(t,1)

    if all((exp_vec .% p) .== indices)

      # this term will not be zero!
      return false
    end
  end

  return true
end#function

# MARK - computing Δ_1

"""
This is not as space-efficient as it could be

Gives the ways of putting the numbers 1...sum(partition)
into length(unique(partition)) boxes where each box
is labeled by a part value and box labeled
by partition[i] has 
count(==(partition[i]),partition) elements

list is assumed to be a list of indices, i.e.
a list of integers with no repeated elements.

partition is assumed to be a list of positive
integers whose which is in increasing or decreasing
order 
(though I think one can get away with each value
being in a contiguous interval of indices, i.e.
[1;1;1;2;2;3] is ok but [1;1;2;1] is not)

The resulting output is an array which has the same
length as partition, whose i'th element is in the
bucket labeled by partition[i]
"""
@memoize function multicombinations(list,partition)
  #TODO: can this be more space-efficient as an iterator??
  # TODO: rewrite this function to allocate memory smarter

  if length(partition) == 0
    return [zeros(eltype(partition),0)]
  end
  
  first = partition[1]
  nFirst = count(==(first),partition)

  result = Vector{Vector{eltype(list)}}()
  for combo in Combinatorics.combinations(list,nFirst)
    withoutfirst = partition[partition .!= first]
    withoutcombo = list[list .∉ (combo,)] # ∉ is \notin 

    for multicombo in multicombinations(withoutcombo,withoutfirst)
      push!(result,[combo; multicombo])
    end
  end

  result
end#function

"""
finds the multicombinations of the set {1, ... n},
where n is the sum of the elements in partition
"""
function multicombinations(partition)
  multicombinations(collect(1:sum(partition)),partition)
end#function

"""
Computes Δ₁(poly) by iterating
through all possible multicombinations 
(cross terms).
"""
function Δ₁(p,poly)
  
  # I don't know how computationally intense these operations are
  #    do them outside any loops just in case.
  terms_iter = terms(poly)
  allterms = collect(terms_iter)
  nTerms = length(allterms)

  res = zero(poly)

  for partition in Combinatorics.partitions(p)
    # the algorithm will still work without this line 
    # because div(1,p) == 0 so coef == 0 below...
    #
    # ...but let's not do the extra work.
    length(partition) == 1 && continue

    distParts = unique(partition)
    nDistParts = length(distParts)
  
    # println("Partition", partition)

    for termlist in Combinatorics.combinations(allterms,length(partition))
      
      coef = div(multinomial(partition...),p)

      # println("Coef: ", coef)

      for multicombo in multicombinations(collect(1:length(partition)),partition)

        # println("Multicombo: ", multicombo)

        newterm = one(poly)
        for i in 1:length(partition)
          exponent = partition[i]
          termind = multicombo[i]
          newterm = newterm * (termlist[termind])^exponent
        end

        # println("Term added: ", newterm)
        res = res + coef * newterm
      end

    end

  end

  res
end#function


"""
Returns Δ₁(poly), computed by
lifting to characteristic zero,
computing the cross terms, and
reducing again
"""
function Δ₁l(p,poly)

  R = parent(poly)

  originallift = map_coefficients(x -> lift(ZZ,x),poly)

  #println("Original Lift: ", originallift)

  ZR = parent(originallift)



  nocrossterms = sum(terms(originallift) .^p)
  withcrossterms = originallift^p

  #println("No cross terms: ", nocrossterms)
  #println("With cross terms: ", withcrossterms)

  crossterms = withcrossterms - nocrossterms

  #println("Just cross terms: ", crossterms)

  Δlift = map_coefficients(x -> div(x,p),crossterms)

  change_coefficient_ring(coefficient_ring(R),Δlift,parent=R)

end#function

"""
If R is the polynomial ring in N variables,
returns a basis for R as an R^p - module,
equivalently returns a basis for
F_*R as an R-module.

"""
function Fstar_basis(p,poly)
  vars = gens(parent(poly))
  n = length(vars)

  numgens = p^n - 1

  generators = zeros(parent(poly),fill(p,n)...)
  for i in CartesianIndices(generators)
    exps = Tuple(i) .- 1
    generators[i] = prod(vars .^ exps)
  end

  vec(generators)
end#function

dim_of_homog_polys(n,d)  = binomial(n+d-1,n-1) # n+d-1 choose n-1

"""
Wrapper for Utils.polynomial_to_vector

Converts the homogeneous polynomial poly
to a vector.

"""
function vector(f,d,order=:lex)
  R = parent(f)
  n = length(gens(R))

  f == zero(R) && return zeros(R,dim_of_homog_polys(n,d))
  @assert d == total_degree(f) "Expect d to be the degree of f"
  F = coefficient_ring(R)
  Utils.polynomial_to_vector(f, n, F, R,order)
end

"""
Takes a linear operator L on the space
of homogenous polynomials 
of degree d and computes 
the matrix representing it.

Currently uses lexographical order

L is a function, which is assumed to be a linear
endomoprhism on the vector space of homogeneous
polynomials.

d is the degree of the homogeneous polynomials.

R is the base ring.

"""
function matrix_of_lin_op(L,d,R,order=:lex)

  n = length(gens(R))
  monomials = Utils.compute_monomials(n,d,R,order)

  m = length(monomials) # will be an mxm matrix

  i = 0

  matrix = zeros(R,m,0)
  for monomial in monomials
    evaled = L(monomial)
    v = vector(evaled,d)
    matrix = [matrix v]

    i = i + 1
    if i % 50 == 0 
      println("50 rows completed")
    end
  end
    
  matrix
end

"""
Lifts a matrix with entries in GF(p) to ZZ and converts the entries
to Julia integers
"""
lift_to_Int64(matrix) = Int64.(map(x -> lift(ZZ,x), matrix))

"""
Gives the index of the "critical term", i.e. the one
that determines whether or not something is quasi-F-split
for a CY manifold. This term is the degree (p-1)^n
monomial x_1^(p-1) ... x_n^(p-1)

"""
function index_of_term_not_in_frobenius_power_CY(p,n,order=:lex)
  R, vars = polynomial_ring(GF(p),n)
  
  crit_term = prod(vars .^ (p-1))

  # perhaps assert this has only one element?
  findfirst(vector(crit_term,total_degree(crit_term)) .!= 0)
end

"""
Returns true if the polynomial poly
is in the "frobenius power" \\frak{m}^[p],
where {m} is the ideal of variables of the ring.

"""
function inPowerOfVariableIdeal(p,m,poly)
  # don't need this because exponent_vectors will have 
  # no elements for the zero polynomial
  poly == zero(poly) && return true


  for i in 1:length(poly)
    ev = exponent_vector(poly,i)

    if all(ev .< m)
      #println("Found term not in the Frob power of the maximal ideal: " * string(exponent_vector))
      
      # We not in the power of the maximal ideal, we don't have any
      # powers that are big enough
      return false
    end
  end

  true
end#function

"""
Returns true if the polyonoimal is homogenous.

doesn't seem to be fully implemented in Oscar :(

try 'is_homogeneous', doesn't seem to be implemented 
for fpMPolyRingElem
"""
function isHomog(poly;ofdegree=-1)

  evs = exponent_vectors(poly)

  if ofdegree == -1 
    all(sum.(evs) .== sum(evs[1]))
  else
    all(sum.(evs) .== ofdegree)
  end
end#function


# MARK - calculations of quasi-F-split height in one form or another

"""
Calculates if the hypersuface defined by the 
polynomial poly is F-split

note that p must be prime for this to have mathematical meaning
"""
function isFSplit(p,poly)
  #maybe TODO: check that p is prime

  !inPowerOfVariableIdeal(p,p,poly^(p-1))

end#function


end#module
